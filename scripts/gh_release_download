#!/usr/bin/env python3
"""
Download release artifacts from GitHub.

The first argument must be the GitHub repository name with the form
'<owner>/<repository>'.

A list of releases available from that repository will be shown.
Enter the corresponding number to select a release, or choose multiple releases
using ',' as a delimiter.

A list of available downloads (assets) for the selected releases will be shown.
Select one or more assets to download them.
"""

import argparse
import json
import sys
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, TextIO, Tuple
from urllib import request

from pkg_resources import parse_version

DATETIME_FMT = "%Y-%m-%dT%H:%M:%SZ"


@dataclass
class CliArgs:
    """Command line arguments."""

    asset: Optional[List[str]]
    latest: bool
    repository: Optional[str]
    tag: Optional[List[str]]


@dataclass
class Asset:
    """Data related to a release asset."""

    download_url: str
    name: str
    size: int

    def __str__(self) -> str:
        """Return the string representation of the asset."""
        size, unit = human_readable_size(self.size)
        return f"{self.name} ({size} {unit})"


@dataclass
class Release:
    """Data related to a release."""

    assets: List[Asset]
    name: str
    published: datetime
    tag: str

    def __str__(self) -> str:
        """Return the string representation of the asset."""
        s = self.name
        if self.name != self.tag:
            s += f" (tag: {self.tag})"
        s += f" - {self.published.date()}"
        return s


def main(argv: List[str], stdout: TextIO) -> int:
    """Download release artifacts from GitHub."""
    args = parse_args(argv)
    if args.repository is None:
        repository = prompt_repo_name(stdout)
    else:
        repository = args.repository
    releases = fetch_release_list(repository)
    selected_releases = select_releases(releases, args.latest, args.tag, stdout)
    all_assets = []
    for release in selected_releases:
        all_assets.extend(release.assets)
    selected_assets = select_asset(all_assets, stdout, args.asset)
    error = False
    for asset in selected_assets:
        error |= download_asset(asset, Path.cwd(), sys.stdout)
    return 1 if error else 0


def parse_args(argv: List[str]) -> CliArgs:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "repository",
        type=str,
        help="the GitHub repository, format <owner>/<repo>",
        default=None,
        nargs="?",
    )
    release_select_group = parser.add_mutually_exclusive_group()
    release_select_group.add_argument(
        "--latest",
        action="store_true",
        help=(
            "select the latest release by comparing releases' tags. "
            "Note that this selects the latest release according to Python's "
            "PEP 440, which means it may not work effectively for all "
            "versioning systems"
        ),
    )
    release_select_group.add_argument(
        "-t",
        "--tag",
        nargs="+",
        default=None,
        help="download assets from a release, or releases, with a specific tag or tags",
    )
    parser.add_argument(
        "-a",
        "--asset",
        nargs="+",
        default=None,
        help="download assets matching at least on of the given regex patterns",
    )
    return CliArgs(**vars(parser.parse_args(argv)))


def prompt_repo_name(stdout: TextIO) -> str:
    """Prompt the user to enter a repository's owner and name."""
    repo_owner = get_input("Repository owner: ", stdout)
    repo_name = get_input("Repository name:  ", stdout)
    return f"{repo_owner}/{repo_name}"


def select_releases(
    releases: List[Release], latest: bool, tags: Optional[List[str]], stdout: TextIO
) -> List[Release]:
    """Select the release or releases to download assets from."""
    if latest:
        release = select_releases_latest(releases)
        stdout.write(f"latest release: {release.tag}\n")
        return [release]
    if tags:
        releases = select_releases_tag(releases, tags)
        stdout.write(f"releases: {', '.join([r.tag for r in releases])}\n")
        return releases
    return select_releases_interactive(releases, stdout)


def select_releases_tag(releases: List[Release], tags: List[str]) -> List[Release]:
    """Select the releases in the given list that match any of the given tags."""
    selected = [release for release in releases if release.tag in tags]
    if not selected:
        raise ValueError(f"no tags matching any of {str(tags)[1:-1]}")
    return selected


def select_releases_interactive(
    releases: List[Release], stdout: TextIO
) -> List[Release]:
    """Get user to select from a list of releases."""
    for i, release in enumerate(releases):
        stdout.write(f"[{i}] {release}\n")
    while True:
        selection = get_input("Pick a release: ", stdout)
        selections = [s.strip() for s in selection.split(",")]
        if not all(s.isdigit() for s in selections):
            continue
        try:
            out = [releases[int(s)] for s in selections]
            stdout.write("\n")
            return out
        except IndexError:
            continue


def select_releases_latest(releases: List[Release]) -> Release:
    """
    Return the 'latest' release from the given list.

    Note the latest version is retrieved according to PEP 440, which may
    not apply to some versioning systems. This is at best, an educated
    guess of which version is the latest.
    """
    if not releases:
        raise ValueError("no releases to select from.")
    if len(releases) == 1:
        return releases[0]
    latest = releases[0]
    for release in releases[1:]:
        try:
            latest_version = parse_version(latest.tag)
            version = parse_version(release.tag)
        except ValueError as exc:
            raise ValueError(
                "could not get latest version, could not parse version"
            ) from exc
        if version > latest_version:
            latest = release
    return latest


def select_asset(
    assets: List[Asset], stdout: TextIO, patterns: Optional[List[str]]
) -> List[Asset]:
    """Get user to select from a list of assets."""
    if patterns:
        return match_select_asset(assets, patterns)
    else:
        return prompt_select_asset(assets, stdout)


def match_select_asset(assets: List[Asset], patterns: List[str]) -> List[Asset]:
    """Return the assets that match one of the given regex patterns."""
    import re

    re_patterns = [re.compile(p) for p in patterns]
    return [a for a in assets if any(re.search(p, a.name) for p in re_patterns)]


def prompt_select_asset(assets: List[Asset], stdout: TextIO) -> List[Asset]:
    """Prompt the user to select a list of assets."""
    for i, asset in enumerate(assets):
        stdout.write(f"[{i}] {asset}\n")
    while True:
        selection = get_input("Pick an asset: ", stdout)
        selections = [s.strip() for s in selection.split(",")]
        if not all(s.isdigit() for s in selections):
            continue
        try:
            out = [assets[int(s)] for s in selections]
            stdout.write("\n")
            return out
        except IndexError:
            continue


def get_input(prompt: str, stdout: TextIO) -> str:
    """Get input, but fail gracefully given EOFError or KeyboardInterrupt."""
    try:
        return input(prompt)
    except (EOFError, KeyboardInterrupt):
        stdout.write("\n")
        sys.exit(1)


def gh_release_request(repo: str) -> List[Dict[str, Any]]:
    """Request releases data from GitHub for the given repository."""
    url = f"https://api.github.com/repos/{repo}/releases"
    try:
        with request.urlopen(url) as response:
            return json.loads(response.read())
    except Exception as exc:
        sys.stderr.write(
            f"gh_release_download: could not retrieve releases for '{repo}': {exc}\n"
        )
        sys.exit(1)


def fetch_release_list(repo: str) -> List[Release]:
    """Retrieve a list of release for the given GitHub repository."""
    releases_data = gh_release_request(repo)
    releases = []
    for release_data in releases_data:
        releases.append(
            Release(
                name=release_data["name"],
                tag=release_data["tag_name"],
                assets=parse_assets(release_data["assets"]),
                published=datetime.strptime(release_data["published_at"], DATETIME_FMT),
            )
        )
    return releases


def parse_assets(assets_data: List[Dict[str, Any]]) -> List[Asset]:
    """Parse an asset from the data retrieved in a GitHub API request."""
    assets = []
    for asset_data in assets_data:
        assets.append(
            Asset(
                name=asset_data["name"],
                download_url=asset_data["browser_download_url"],
                size=asset_data["size"],
            )
        )
    return assets


def download_asset(asset: Asset, out_dir: Path, stdout: TextIO) -> bool:
    """Download the given asset from GitHub."""
    progress_bar = DownloadProgressBar(asset.name, stdout)
    try:
        request.urlretrieve(
            asset.download_url, out_dir / asset.name, reporthook=progress_bar
        )
        stdout.write("\n")
    except Exception as exc:
        sys.stderr.write(
            f"\ngh_release_download: could not download asset '{asset.name}': {exc}\n"
        )
        return True
    return False


class DownloadProgressBar:
    """Simple progress bar."""

    def __init__(self, prefix: str, stdout: TextIO = sys.stdout) -> None:
        self.prefix = prefix
        self.stdout = stdout

    def __call__(self, block_num: int, block_size: int, total_size: int) -> None:
        """Callback function for urlretrieve's `reporthook`."""
        bar_len = 38
        num_blocks = max(total_size / block_size, 1)
        percentage = float(block_num) / num_blocks
        num_full = int(bar_len * percentage)
        sys.stdout.write("\r")
        sys.stdout.write(
            f"{self.prefix} [{'#'*num_full}{' '*(bar_len - num_full)}] "
            f"{min(int(percentage*100), 100)}%"
        )
        sys.stdout.flush()


def human_readable_size(num: int) -> Tuple[str, str]:
    """
    Return the given number of bytes in a human readable form.

    https://stackoverflow.com/a/1094933.
    """
    for unit in ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB"]:
        if abs(num) < 1024.0:
            break
        num /= 1024.0
    return f"{num:.0f}", unit


if __name__ == "__main__":
    try:
        sys.exit(main(sys.argv[1:], sys.stdout))
    except Exception as exc:
        sys.stderr.write(f"gh_release_download: error: {exc}\n")
        sys.exit(1)
